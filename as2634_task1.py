import random


def exp(base: int, power: int):
    if power == 0:
        return 1
    elif power == 1:
        return base
    elif power < 0:
        return exp(1 / base, base * (-1))
    elif power % 2 == 0:
        return exp(base * base, power / 2)
    else:
        return base * exp(base * base, (power - 1) / 2)


def extended_euclidean_algorithm(a, b):
    r1, r = a, b
    s1, s = 1, 0
    t1, t = 0, 1

    while r != 0:
        q1 = int((r1 // r))
        r1, r = r, (r1 - (q1 * r))
        s1, s = s, (s1 - (q1 * s))
        t1, t = t, (t1 - (q1 * t))
        d = r1
        x = s1
        y = t1
        rr = r
        if rr == 0:
            return d, x, y


def generate_prime_number(limit):
    p = 0
    is_prime = False
    init_range = exp(2, limit - 1)
    val_range = exp(2, limit)
    while not is_prime:
        p = random.randint(init_range, val_range)
        if p > 2 and check_prime_by_division_trial_method(p) == 1:
            if check_by_fermat_test_method(p, 50) == 1:
                break
    return p


def check_prime_by_division_trial_method(n):
    for x in range(2, 101):
        if x != n and n % x == 0:
            return x
    return 1


def check_by_fermat_test_method(num: int, k):
    for i in range(k):
        a = random.randint(2, num - 1)
        b = exp(a, num - 1) % num
        if b == 1:
            return 1
    return a


def get_negative_number_representation(neg, n):
    neg = abs(neg)
    if neg > (n - 1):
        neg = neg % n
    neg = n - neg
    return neg


def print_separators():
    print(20 * '-')


def encrypt(m: int, e: int, N: int):
    return int(exp(m, e)) % N


def decrypt(c: int, d: int, N: int):
    return int((exp(c, int(d))) % int(N))


nu = int(input(f"Please enter the security parameter `nu': "))
print_separators()
print('Setup:')
limit = int(nu // 2)
p = generate_prime_number(limit)
print(f"The first prime generated by the Setup algorithm is p = {p}")
q = generate_prime_number(limit)
while p == q:
    q = generate_prime_number(limit)
print(f"The second prime generated by the Setup algorithm is q = {q}")
N = p * q
print(f"The integer N = pq = {N}")
M = (p - 1) * (q - 1)

while True:
    i = exp(2, ((nu // 2) - 1))
    e = random.randint(i, M)
    gcd, inverse, y = extended_euclidean_algorithm(e, M)
    if gcd == 1:
        break

if inverse < 0:
    d = get_negative_number_representation(inverse, M)
else:
    d = inverse

print(f'The encryption exponent is e = {e}')
print(f'The decryption exponent is d = {d}')
print_separators()

play = True
while play:
    operation = int(input(f"Please enter an option: \n 1 to Encrypt \n 2 to Decrypt \n Any other number to quit "
                          f"\n Your option:"))
    match operation:
        case 1:
            print('Encryption:')
            print("Your message space is the set {Z/NZ} = {0,1,......,", N - 1, '}')
            m = int(input('Please enter a number from this set:'))
            encrypted_text = encrypt(m, e, N)
            print(f"The ciphertext for your message {m} is {encrypted_text}")
            print_separators()
        case 2:
            print('Decryption:')
            print("Your ciphertext space is the set {Z/NZ} = {0,1,......,", N - 1, '}')
            cipher = int(input('Please enter a number from this set:'))
            decypted_text = decrypt(cipher, d, N)
            print(f"The plaintext for your ciphertext {cipher} is {decypted_text}")
            print_separators()
        case _:
            break
