import random


def generate_prime_factors(n):
    factors = {}

    while n % 2 == 0:
        if 2 in factors:
            factors[2] = factors.get(2) + 1
        else:
            factors[2] = 1
        n = n / 2

    for i in range(3, int(square_root(n)) + 1, 2):

        # while i divides n , print i ad divide n
        while n % i == 0:
            if int(i) in factors:
                factors[int(int(i))] = factors.get(int(i)) + 1
            else:
                factors[int(i)] = 1
            n = n / i
    if n > 2:
        if int(n) in factors:
            factors[int(n)] = factors.get(int(n)) + 1
        else:
            factors[int(n)] = 1
    # calling function
    return factors


def square_root(num: int) -> int:
    return pow(num, 1 / 2)


def exp(base: int, power: int):
    if power == 0:
        return 1
    elif power == 1:
        return base
    elif power < 0:
        return exp(1 / base, base * (-1))
    elif power % 2 == 0:
        return exp(base * base, power / 2)
    else:
        return base * exp(base * base, (power - 1) / 2)


def extended_euclidean_algorithm(a, b):
    r1, r = a, b
    s1, s = 1, 0
    t1, t = 0, 1

    while r != 0:
        q1 = int((r1 // r))
        r1, r = r, (r1 - (q1 * r))
        s1, s = s, (s1 - (q1 * s))
        t1, t = t, (t1 - (q1 * t))
        d = r1
        x = s1
        y = t1
        rr = r
        if rr == 0:
            return d, x, y


def legendre_calculation(a, p):
    power = int((p - 1) / 2)
    num = (exp(a, power)) % p
    if num > 1 and ((num + 1) % p) == 0:
        return -1
    else:
        return num


def jacobi_calculation(a, p):
    if a == 0:
        return 0
    if a == 1:
        return 1
    dic = generate_prime_factors(p)
    result = 1
    for key in dic:
        result = result * exp(legendre_calculation(a, key), dic[key])
    return result


def generate_prime_number(limit):
    p = 0
    is_prime = False
    init_range = exp(2, limit - 1)
    val_range = exp(2, limit)
    while not is_prime:
        p = random.randint(init_range, val_range)
        if check_prime_by_division_trial_method(p) == 1:
            if check_by_fermat_test_method(p, 50) == 1:
                break
    return p


def check_prime_by_division_trial_method(n):
    for x in range(2, 101):
        if x != n and n % x == 0:
            return x
    return 1


def check_by_fermat_test_method(num: int, k):
    for i in range(k):
        a = random.randint(2, num - 1)
        b = exp(a, num - 1) % num
        if b == 1:
            return 1
    return a


def chinese_remainder_theorem(a: int, M: int, b: int, N: int) -> int:
    d, x, y = extended_euclidean_algorithm(M, N)

    if d != 1:
        return 0
    if x < 0:
        t = N + x
    else:
        t = x

    u: int = ((b - a) * t) % N

    return a + u * M


def get_gcd_by_euclidean(a: int, b: int):
    r: int = b
    while r != 0:
        r = a % b
        a = b
        b = r

    return a


def get_mutually_prime_elements(N: int) -> list:
    mutually_prime_list = []
    for i in range(1, N - 1):
        if get_gcd_by_euclidean(i, N) == 1:
            mutually_prime_list.append(i)
    return mutually_prime_list


def check_if_valid_cipher(num: int, N: int):
    if get_gcd_by_euclidean(num, N) == 1 and jacobi_calculation(num, N) == 1:
        return True


def encrypt(bit, y, N) -> int:
    mutually_prime_elements = get_mutually_prime_elements(N)
    index = random.randint(0, len(mutually_prime_elements))
    x = mutually_prime_elements[index]
    if bit == 0:
        c = exp(x, 2) % N
        return c
    elif bit == 1:
        c = (y * exp(x, 2)) % N
        return c


def decrypt(c: int, p: int) -> int:
    result = legendre_calculation(c, p)
    if result == 1:
        return 0
    elif result == -1:
        return 1


def print_separators():
    print(20 * '-')


nu = int(input(f"Please enter the security parameter `nu': "))
print_separators()
print('Setup:')
limit = nu // 2
p = generate_prime_number(int(limit))
print(f"The first prime generated by the Setup algorithm is p = {p}")
q = generate_prime_number(limit)
while p == q:
    q = generate_prime_number(limit)
print(f"The second prime generated by the Setup algorithm is q = {q}")
N = p * q
print(f"The integer N = pq = {N}")
ya, yb = 0, 0
while legendre_calculation(ya, p) != -1:
    ya = random.randint(1, p)

while legendre_calculation(yb, q) != -1:
    yb = random.randint(1, q)

y: int = chinese_remainder_theorem(ya, p, yb, q)
print(f"The public key y = {y}")
print_separators()

play = True
while play:
    operation = int(input(f"Please enter an option: \n 1 to Encrypt \n 2 to Decrypt \n Any other number to quit "
                          f"\n Your option:"))
    match operation:
        case 1:
            print('Encryption:')
            print('Your message space is the set: {0, 1}')
            m = int(input('Please enter a number from this set:'))
            c: int = encrypt(m, y, N)
            print(f"The ciphertext for your message {m} is {c}")
            print_separators()
        case 2:
            print('Decryption:')
            print(f'Your ciphertext space is the set J_{N}')
            m = int(input('Please enter a number from this set:'))
            while not check_if_valid_cipher(m, N):
                m = int(input('Please enter a number from this set:'))
            d = decrypt(m, p)
            print(f"The plaintext for your ciphertext {m} is {d}")
            print_separators()
        case _:
            break
